# Lecture 11Thread Switching
Thread: one serial execution


# lab6 Multithreading
##  Uthread: switching between threads


```C
void

thread_create(void (*func)())

{

  struct thread *t;

  
  for (t = all_thread; t < all_thread + MAX_THREAD; t++) {

    if (t->state == FREE) break;

  }

  t->state = RUNNABLE;

  // YOUR CODE HERE

  //t->stack[0] = func;

  t->context.sp = (uint64)func;

}
```


# lab10 Mmap

对于mmap，其函数定义为

void \*mmap(void \*addr, size_t length, int prot, int flags,int fd, off_t offset);

其对给定的address，将file descriptor对应的文件写入到之中，prot表示对其的权限，如**PROT_READ**表示memory可读，**PROT_WRITE**表示memory可写，flags表示对mapped memory的修改是否要写回到原文件中，**MAP_SHARED**表示修改需要写回到文件中，**MAP_PRIVATE**表示修改不需要写回，offset表示文件开始的偏移量。

首先将_mmaptest添加到Makefile的UPROGS中
```Makefile
UPROGS=\

    $U/_cat\

    $U/_echo\

    $U/_forktest\

    $U/_grep\

    $U/_init\

    $U/_kill\

    $U/_ln\

    $U/_ls\

    $U/_mkdir\

    $U/_rm\

    $U/_sh\

    $U/_stressfs\

    $U/_usertests\

    $U/_grind\

    $U/_wc\

    $U/_zombie\

    $U/_mmaptest\
```

将mmap和munmap添加到system call中

在usys.pl中添加
```python
entry("mmap"); 

entry("munmap");
```

在user.h中添加
```c
void *mmap(void *,int,int,int,int,int); 

int munmap(void *,int);  
```

在syscall.h中添加
```c
#define SYS_mmap   22

#define SYS_munmap 23
```

在syscall.c中添加
```c
extern uint64 sys_mmap(void); //lab10

extern uint64 sys_munmap(void);//lab10


[SYS_mmap]    sys_mmap,

[SYS_munmap]  sys_munmap,
```

对VMA进行定义，在proc.h中定义struct VMA,并且在struct proc中添加struct VMA vma[VMAMAX]，使每一个process中都存有相应的VMA，用其来存储mmap的一些数据。
```c
struct VMA{

  uint64 address;

  int use;

  int length;

  int fd;

  int offset;

  struct file  *vfile;

  int flag;

  int prot;

  int restlength;

};
#define VMAMAX 16


```


在trap中，对于page faults，即r_scause()\==13 或者r_scause()\==15，在trap.c的usertrap()中添加对应的处理，以lazy page allocation的方式。
这里面有一些要注意的地方，比如判断地址是否溢出、readi()操作的地址选择，对于readi()操作的起始地址选择，因为实验中总是假设offset为0，因此readi()的起始offset为当前的address减去对应VMA的起始address。
```c
else if(r_scause()==13||r_scause()==15){

    uint64 address = r_stval();

    if(address>=p->sz || address<p->trapframe->sp){   //判断是否超出地址空间

      p->killed=1;

    }else{

    char* pa;

    int k=0;

    for(int i=0;i<VMAMAX;i++){      //寻找对应的VMA

      if(p->vma[i].use){

        if(p->vma[i].address <= address&& p->vma[i].address+p->vma[i].length-1>=address){

            k=i;

            break;

        }

      }

    }

    if(k==VMAMAX){        //若没有找到对应的VMA，则结束此进程

      p->killed=1;

    }

    else{

      struct file *f = p->vma[k].vfile;   //获取对应的文件
 
      struct inode *ip = f->ip;

      pa =  kalloc();

      if(pa==0){

        p->killed=1;

      }

      else{

        if(PGROUNDUP(p->trapframe->sp) - 1 < address && address < p->sz &&address<MAXVA) {

          memset(pa, 0, PGSIZE);    //将分配的物理页全部置0

          ilock(ip);           //进行readi操作必须要上锁

          readi(ip, 0, (uint64)pa,address-p->vma[k].address, PGSIZE);   //the offset has some problem

          iunlock(ip);

          if(mappages(p->pagetable, PGROUNDDOWN(address), PGSIZE, (uint64)pa, p->vma[k].flag) != 0) {

            kfree(pa);

            p->killed = 1;

          }

      }

        else{

          p->killed=1;

        }

      }

    }

    }

  }
```

